---
title: "Introduction to individual-based modelling using R"
author: "Brad Duthie"
date: "20 Februrary 2019"
output: 
    html_document:
        code_folding: show
bibliography: ibm_refs.bib
---

Contents
================================================================================

********************************************************************************

**Note: Please think of this document as a living document, which you are free to improve (like a [wiki](https://en.wikipedia.org/wiki/Wiki)) with minor edits, new sections that others might find useful, or [additional resources](#whatelse) that you find that you think others might also find useful. After reading through this, you will have been introduced to the basics of building individual-based models (IBMs), and you should be able to start coding your own IBMs in R**

********************************************************************************

- [Introduction: What is an individual-based model (IBM)?](#intro)
- [Getting started with IBMs in R](#Rstart)
- [Movement of individuals on a landscape](#move)
- [Simulating individual movement over time](#time)

********************************************************************************

<a name="intro">Introduction: What is an individual-based model?</a>
================================================================================


- Note that the code here is not optimised for efficiency. It is written to be as easy to learn as possible.

<a name="initialise">Getting started with IBMs in R</a>
================================================================================

In an IBM, discrete individuals are represented by some sort of data structure in code (e.g., a list, table, array, or potentially some type of customised structure). There are several possible ways to do this, and the way that works best is probably most often a matter of the modeller's preference and the coding language that they are using. In R, there are a few possibilities, but I usually find the most intuitive way to model individuals is using a data table or array. For example, we can think about a two dimensional array as modelling a population of individuals, with rows representing discrete individuals and columns representing those individuals' characteristics ('characteristic' is not a technical term here; I am loosely defining it to mean anything that relates to the individual in some way). The code below creates a two dimensional data array (`inds`) to model five individuals that have three characteristics each.

```{r}
inds           <- array(data = 0, dim = c(5, 3));
colnames(inds) <- c("characteristic_1", "characteristic_2", "characteristic_3");
rownames(inds) <- c("ind_1", "ind_2", "ind_3", "ind_4", "ind_5");
print(inds);
```

The row and column names are not required, but I have included them to make it easier to refer back to individuals and their characteristics. I have initialised all individual characteristics with a value of zero because it is still undecided what characteristics are actually being modelled. Characteristics can be anything we want them to be, from phenotypic traits, to alleles, to spatial locations, to some sort of temporary status (e.g., feeding or not feeding). The whole `inds` array is like a data set in which some number of measurements (columns) have been taken for some number of individuals (rows), except that we can make these measurements up to be whatever we want them to be, and manipulate them according to whatever rules we want to model. The objective is to carefully choose a set of characteristics and rules that model whatever biological process it is that we are trying to better understand.

We can start with some very simple individual characteristics. Assume that we want to model a population of animals moving around a landscape, and we want to include animal body mass and location as characteristics. We can use use 'characteristic_1' in column 1 to randomly assign each individual a body mass according to some selected distribution, while 'characteristic_2' in column 2 and 'characterist_3' in column 3 can be assigned random x and y locations, respectively. I will change the columns to reflect the new modelling decision for individual characteristics below.

```{r}
colnames(inds) <- c("body_mass", "x_loc", "y_loc");
```

Let us say that body mass is normally distributed around a value of 23 with a standard deviation of 3. If it helps the reader to have a concrete example in mind to visualise, this is roughly the body mass distribution in kilograms of female [roe deer](https://en.wikipedia.org/wiki/Roe_deer) [@Pettorelli2002]. Nevertheless, it is usually not important to have any particular species in mind unless the model is being constructed to address a very targeted question. We can give each individual a body mass randomly sampled from $\mathcal{N}(23, 3)$ with the code below.

```{r}
inds[,1] <- rnorm(n = dim(inds)[1], mean = 23, sd = 3);
```

Note that `dim(inds)` returns the dimensions of the array `inds` where element 1 (i.e., `dim(inds)[1]`) is the number of rows (`r dim(inds)[1]` in this case) and element 2 is the number of columns (`r dim(inds)[2]` in this case). Also note that that in the code above, `inds[, 1]` returns all of the values in column 1; it is the same as if we had typed `inds[1:5, 1]`. Each individual in the array is now modelled with a unique body mass in the first column.

```{r, echo = FALSE}
print(inds);
```

We can now give each individual its own location. Assume that these individuals all occupy some location on an $8 \times 8$ grid like the one shown below.

```{r, echo = FALSE, fig.height = 6, fig.width = 6, fig.align = "center"}
par(mar = c(5, 5, 1, 1));
plot(x = 1:8, y = 1:8, type = "n", xaxt = "n", yaxt = "n", xlab = "x location", 
     ylab = "y location", xlim = c(0.5, 8.5), ylim = c(0.5, 8.5), yaxs= 'i', 
     xaxs = 'i', cex.lab = 1.5);
axis(side = 1, at = 1:8, labels = 1:8, cex.axis = 1.5);
axis(side = 2, at = 1:8, labels = 1:8, cex.axis = 1.5);
pt <- seq(from = 0.5, to = 7.5, length = 8);
for(i in 1:8){
    abline(v = pt[i]);
    abline(h = pt[i]);
}
```

We do not actually need to code this grid to model individual locations or movement, but it might help to think of each individual in our model as occupying some square (i.e., 'cell') on the grid above. This is just one way to model individual position on a spatially explicit landscape, but it is often especially useful because it allows us to use natural numbers to define how far away individuals are from one another (number of cells away), and when individuals occupy the exact same location. We can now set individual x and y locations into columns 2 and 3, respectively, by sampling from a vector of numbers 1 to 8 with replacement (sampling with replacement ensures that more than one individual can occupy the same x or y location).

```{r, echo = TRUE}
inds[,2] <- sample(x = 1:8, size = dim(inds)[1], replace = TRUE);
inds[,3] <- sample(x = 1:8, size = dim(inds)[1], replace = TRUE);
```

```{r, echo = FALSE}
inds[,3] <- sample(x = 1:8, size = dim(inds)[1], replace = FALSE);
for(i in 1:dim(inds)[1]){
    if(inds[i, 2] == 8){
        inds[i, 2] <- 7;   
    }
    if(inds[i, 2] == 1){
        inds[i, 2] <- 2;   
    }
    if(inds[i, 3] == 8){
        inds[i, 3] <- 7;   
    }
    if(inds[i, 3] == 1){
        inds[i, 3] <- 2;   
    }
}
```

Each individual now occupies a location on the landscape, as shown now in columns 2 and 3.

```{r, echo = FALSE}
print(inds);
```

We can even plot the individuals' x and y locations to see how they are spatially distributed.

```{r, fig.height = 6, fig.width = 6, fig.align = "center"}
plot(x = inds[,2], y = inds[,3], pch = 20, cex = 4, xlim = c(1, 8),
     ylim = c(1, 8), xlab = "x location", mar = c(5, 5, 1, 1),
     ylab = "y location", cex.lab = 1.5, cex.axis = 1.5);
```

This is really all that is needed to get started. It is, of course, possible to add any number of individuals (rows) or individual characteristics (columns). And it is not necessary to model body mass or even spatial location if these are not useful characteristics for modelling the system of interest. What matters is that we have a discrete number of individuals with some set of characteristics that are relevant for whatever question it is that we want to answer. These individuals and characteristics will change over the course of simulating an IBM according to whatever rules we specify. This can include rules for movement, mating, birth, death, or anything else that we might think is important to model in the system. In the next section, we can consider some simple rules for individual movement.

<a name="move">Movement of individuals on a landscape</a>
================================================================================

Each of the individuals we initialised in the [previous section](#initialise) has an x and y location on the landscape. To model individual movement, we need to come up with some rule for how these locations change. The simplest model of movement is to allow individuals to increase or decrease their x and y locations by 1 cell, so `ind_1` with an x location of `r inds[1,2]` might move along the x axis to a new x location of `r inds[1,2] + 1` or `r inds[1,2] - 1`. The individual might likewise move up or down one cell on the y axis. To model random movement to any of the eight cells surrounding a focal individual's current location (also allowing diagonal movement), we can sample two random integer values from the set $\{-1, 0, 1\}$ with replacement and equal probability. One value is for the x location, and the other is for the y location. Movement is modelled by adding each value to the current x and y locations; the code below moves `ind_1` in the first row of `inds`.

```{r}
x_move     <- sample(x = c(-1, 0, 1), size = 1);
y_move     <- sample(x = c(-1, 0, 1), size = 1);
inds[1, 2] <- inds[1, 2] + x_move;
inds[1, 3] <- inds[1, 3] + y_move;
```

```{r, echo = FALSE}
old_x <- inds[1, 2] - x_move;
old_y <- inds[1, 3] - y_move;
if(x_move == 0 & y_move == 0){
    old_x     <- inds[1,2];
    inds[1,2] <- inds[1,2] - 1;
}
```

We can see the new location in the table `inds`, and we can plot the individuals' locations again with the location of `ind_1` shown in red. The arrow below indicates the original cell from which `ind_1` moved.

```{r, echo = FALSE, fig.height = 6, fig.width = 6, fig.align = "center"}
print(inds);
plot(x = inds[,2], y = inds[,3], pch = 20, cex = 4, xlim = c(1, 8),
     ylim = c(1, 8), xlab = "x location", mar = c(5, 5, 1, 1),
     ylab = "y location", cex.lab = 1.5, cex.axis = 1.5);
points(x = inds[1,2], y = inds[1,3], pch = 20, cex = 4.2, col = "red");
points(x = old_x, y = old_y, pch = 20, cex = 4);
arrows(x0 = old_x, x1 = inds[1,2], y0 = old_y, y1 = inds[1,3], length = 0.1,
       lwd = 3);
```

This was only one individual, but we can move all of the individuals simultaneously according to our movement rule if we sample a vector of `x_move` and `y_move` that matches the number of individuals in the array. The code below samples two movement vectors that are the same length as the number of rows in `inds` (i.e., one value of -1, 0, or 1 sampled for each individual's x and y location).

```{r}
x_move    <- sample(x = c(-1, 0, 1), size = dim(inds)[1], replace = TRUE);
y_move    <- sample(x = c(-1, 0, 1), size = dim(inds)[1], replace = TRUE);
inds[, 2] <- inds[, 2] + x_move;
inds[, 3] <- inds[, 3] + y_move;
```

```{r, echo = FALSE}
for(i in 1:dim(inds)[1]){
    if(inds[i, 2] == 9){
        inds[i, 2] <- 7;   
    }
    if(inds[i, 2] == 0){
        inds[i, 2] <- 2;   
    }
    if(inds[i, 3] == 9){
        inds[i, 3] <- 7;   
    }
    if(inds[i, 3] == 0){
        inds[i, 3] <- 2;   
    }
}
```

We can now see their new positions in the data array columns 2 and 3, and compare the new values in these columns with the old one above to verify that individuals have indeed moved, at most, one cell in either direction.

```{r, echo = FALSE}
print(inds);
```

We can see that the x and y locations have not changed by more than a single value. Double-checking code in this way is generally a very good idea at every step of the modelling process. It is very easy to overlook a coding error that might cause a much different rule than the one intended. To be especially vigilant, it is often a good idea to give each unique process in an IBM its own function. There are at least three benefits of coding this way. First, it will later allow us to test each process in the IBM independently, so that if one part of the model does not appear to be working as it should, then we can narrow down the problem more easily by checking each function. Second, it makes it easier to change the order of operations in our IBM (e.g., whether movement happens before, or after, mating, birth, or death processes). Third, it makes the code easier to read; rather than having to scan through all of the code at once to understand a model, we can break things down piece by piece (this will become clearer later). Below, I write a function to move individuals on the landscape according to the movement rules described above.

```{r}
movement <- function(inds, xloc = 2, yloc = 3){
    total_inds   <- dim(inds)[1]; # Get the number of individuals in inds
    move_dists   <- c(-1, 0, 1);  # Define the possible distances to move
    x_move       <- sample(x = move_dists, size = total_inds, replace = TRUE);
    y_move       <- sample(x = move_dists, size = total_inds, replace = TRUE);
    inds[, xloc] <- inds[, xloc] + x_move;
    inds[, yloc] <- inds[, yloc] + y_move;
    return(inds);
}
```

We now have a function `movement`, which takes in three arguments (`inds`, `xloc`, and `yloc`) and returns an updated array of individuals with new x and y locations. The argument `inds` is the array of individuals that we want to move, while `xloc` and `yloc` are the column numbers where the x and y locations of individuals are stored, respectively (default values are set to 2 and 3). Of course, we could have not included `xloc` and `yloc` as function arguments, and instead just added 2s and 3s where `xloc` and `yloc` appear within the `movement` function. But specifying these arguments makes the function more flexible. Now if we want to change which of the individual array `inds` columns specify location, for whatever reason, we need only specify a different `xloc` and `yloc` when calling the `movement` function. We could do the same with `move_dists`, if we wanted to make `movement` even more flexible.

To move individuals in the array `inds`, we now only need to call the `movement` function. As a reminder, here is what `inds` looks like now.

```{r, echo = FALSE}
print(inds);
```

Below moves the individuals with only one line of code using our new function. Note that we do not need to specify `xloc` and `yloc` arguments because we are happy with the default values of 2 and 3, respectively.

```{r}
inds <- movement(inds);
```

The new `inds` array is below.

```{r, echo = FALSE}
for(i in 1:dim(inds)[1]){
    if(inds[i, 2] == 9){
        inds[i, 2] <- 7;   
    }
    if(inds[i, 2] == 0){
        inds[i, 2] <- 2;   
    }
    if(inds[i, 3] == 9){
        inds[i, 3] <- 7;   
    }
    if(inds[i, 3] == 0){
        inds[i, 3] <- 2;   
    }
}
print(inds);
```


Now that we have some code that has been tested and works as intended, we can use it to simulate the movement of individuals over multiple time steps. I will show how to do this in the next section.


<a name="time">Simulating individual movement over time</a>
================================================================================

To simulate the movement of our individuals over time, we now need to call the `movement` function that we wrote in [the previous section](#move) multiple times. We can define the total number of time steps to simulate over below.

```{r}
time_steps <- 20;
```

To run a simulation of individuals moving for twenty time steps, we now need to use [a loop](https://stirlingcodingclub.github.io/using_loops/loop_notes.html). A `while` loop in which some variable `ts` (indicating 'time step') increases from 0 to 19 is probably the easiest way to code the simulation.

```{r}
ts <- 0;
while(ts < time_steps){
    inds <- movement(inds);
    ts   <- ts + 1; 
}
```

The code above first sets the starting time step to a value of 0. Within the `while` loop, individuals in the `inds` array are moved, then the time step value is increased by one. The loop continues calling `movement` to move individuals until the condition in the while loop (`ts < time_steps`) is satisfied. After the loop is finished, individuals have moved ten times from their initial starting locations. Here is where they are located now.

```{r, echo = FALSE}
print(inds);
```

The code appears to have worked, but there is a problem that we have not yet considered. We originally defined our landscape as an $8 \times 8$ grid, but there is nothing in the movement rules preventing individuals from moving off of the landscape. This might not matter to us; perhaps we are happy to assume that some individuals will migrate outside of the area of interest. But often we want the population to be enclosed, and for individuals to not leave it by moving outside the bounds that we have set. If this is the case, then we need to decide what happens when individuals move past the edge of the landscape. There are several possibilities for what to do when individuals move outside of the landscape boundary.

1. Place them back onto the boundary edge (i.e., a sticky landscape edge).
2. Change their direction at the boundary edge (i.e., a reflecting landsacpe edge).
3. Have them move to the opposite side of the landscape (i.e., no a torus landscape with no edge)

In my experience, 3 is the most popular option, perhaps because it eliminates the problem of what to do with individuals that leave the edge of the landsacpe altogether (by making it so that no edge exists). For now, I will demonstrate a reflecting edge instead because it is slightly easier to code. To make individuals that move one cell past the boundary of the landscape instead move back one cell toward the centre of the landscape, we can add some new code to the `movement` function.

```{r}
movement <- function(inds, xloc = 2, yloc = 3, xmax = 8, ymax = 8){
    total_inds   <- dim(inds)[1]; # Get the number of individuals in inds
    move_dists   <- c(-1, 0, 1);  # Define the possible distances to move
    x_move       <- sample(x = move_dists, size = total_inds, replace = TRUE);
    y_move       <- sample(x = move_dists, size = total_inds, replace = TRUE);
    inds[, xloc] <- inds[, xloc] + x_move;
    inds[, yloc] <- inds[, yloc] + y_move;
    # =========   The reflecting boundary is added below
    for(i in 1:total_inds){               # For each individual in the array
        if(inds[i, xloc] > xmax){         # If it moved passed the maximum xloc
            inds[i, xloc] <- xmax - 1;    # Then move it back toward the centre
        }
        if(inds[i, xloc] < 1){            # If it moved below 1 on xloc
            inds[i, xloc] <- 2;           # Move it toward the centre (2)
        }
        if(inds[i, yloc] == ymax){        # If it moved passed the maximum yloc
            inds[i, yloc] <- ymax - 1;    # Then move it back toward the centre
        }
        if(inds[i, yloc] < 1){            # If it moved below 1 on yloc
            inds[i, yloc] <- 2;           # Then move it toward the centre (2)
        }
    } 
    # =========  Now all individuals should stay on the landscape
    return(inds);
}
```

With the new `movement` function, let us first initialise a new population of `inds` in [the same way as before](#initialise). 

```{r}
inds           <- array(data = 0, dim = c(5, 3));
colnames(inds) <- c("body_mass", "x_loc", "y_loc");
rownames(inds) <- c("ind_1", "ind_2", "ind_3", "ind_4", "ind_5");
inds[,1]       <- rnorm(n = dim(inds)[1], mean = 23, sd = 3);
inds[,2]       <- sample(x = 1:8, size = dim(inds)[1], replace = TRUE);
inds[,3]       <- sample(x = 1:8, size = dim(inds)[1], replace = TRUE);
```

Here is what the newly initialised individuals in `inds` look like.

```{r, echo = FALSE}
print(inds);
```

With our new movement function defined above, we can again simulate movement over ten time steps. This time, though, we should not see any individuals leaving the $8 \times 8$ grid.

```{r}
ts         <- 0;
time_steps <- 20;
while(ts < time_steps){
    inds <- movement(inds);
    ts   <- ts + 1; 
}
print(inds);
```

Individuals have now moved from their original locations after 20 time steps, but none of the individuals has an x or y location less than 1 or greater than 8, meaning that they are all still on the landscape. Hence, we now have a working IBM in which individuals move around randomly on an $8 \times 8$ grid. We have initialised five individuals with three characteristics, but as long as we have x and y locations stored in `inds` columns, we could always increase the number of individuals and characteristics in the model and add new rules (functions) within the above while loop. I will show how to do this in the next section, but before moving on, I want to first show some ways to keep track of what is already going on in our IBM.

Note that in using the loop immediately above, we have successfully modelled animal movement over 20 time steps, but we have not retained any information about where each individual was located *within* these 20 time steps. We only know the x and y locations where the individuals started at `time_step = 0`, and where each of them ended at `time_step = 19`. This might not be a problem; perhaps the intervening locations do not really matter to us. Or maybe this would be too much information to store[^1]. But suppose that we actually wanted to record the locations of all of these individuals in each time step, and new that storing these data would not be an issue. Doing so would allow us to reconstruct the movement patterns of each individual and see how the whole population moves from time step 0 to time step 20. In R, we can do this easily by creating a new list and storing the `inds` array as a list element in each time step.

```{r}
ts         <- 0;
time_steps <- 20;
inds_hist  <- NULL;
while(ts < time_steps){
    inds            <- movement(inds);
    ts              <- ts + 1; 
    inds_hist[[ts]] <- inds;
}
print(inds);
```

With the addition of the `inds_hist` list, we can see where every individual was in each time step. For example, we can look at individual movement in the first three time steps by printing `inds_hist` elements below (note that `inds_hist[[1:3]]` does not work in R -- we need to print line by line, or use a loop).

```{r, echo = TRUE}
print(inds_hist[[1]]);
print(inds_hist[[2]]);
print(inds_hist[[3]]);
```

The `inds_hist` list essentially stores the entire history of the individuals moving over the course of the simulation. Storing this kind of information is very useful for reconstructing the history of a simulation to understand what is going on. As more biological processes are added (e.g., birth, death, predation, etc.), we can effectively take a perfect snapshot of each point in time in the system that we are modelling. Often the sheer size of an IBM prohibits a complete record of every individual's history, but as the IBM grows, we can choose what information is important to retain and analyse. For now, because the the model is small (few individuals and time steps), we can simply keep everything. Model analysis then becomes a process of extracting the relevant information that we have stored during the simulation and using it to make meaningful biological inferences. We could, for example, see where individual 1 has been over the 20 time steps by extracting the information from `inds_hist` and storing it in a new table.

```{r}
ind1_locs <- array(data = NA, dim = c(20, 3));
for(i in 1:20){
    ind1_locs[i, 1] <- i                     # Save the time step
    ind1_locs[i, 2] <- inds_hist[[i]][1, 2]; # xloc for the time step
    ind1_locs[i, 3] <- inds_hist[[i]][1, 3]; # yloc for the time step
}
colnames(ind1_locs) <- c("time_step", "x_loc", "y_loc");
print(ind1_locs);
```

The array above shows the full path of individual 1 from x location `r ind1_locs[1,2]` and y location `r ind1_locs[1,3]` to x location `r ind1_locs[20,2]` and y location `r ind1_locs[20,3]`.


References
================================================================================


[^1]: This has happened to me once, on accident, when coding [an IBM for plant-pollinator-exploiter interactions](https://github.com/bradduthie/Duthie_and_Falcy_2013) [@Duthie2013]. While testing my code, I had been printing off the locations of all individuals in the IBM to a text file. Later, upon running a large number of simulations, I noticed that my computer was slowing down quite a bit. Soon, a warning message came up that there was no more space to write to my hard drive. Because I had forgotten to stop printing all individual locations to the text file, every new location of millions of individuals was being recorded. The text file was well over 150 gigabytes when I forced the simulations to terminate, then removed the bit of code that printed individual locations.


